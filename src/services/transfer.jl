# This file is auto-generated by AWSMetadata.jl
using AWS
using AWS.AWSServices: transfer
using AWS.Compat
using AWS.UUIDs

"""
    create_access(external_id, role, server_id)
    create_access(external_id, role, server_id, params::Dict{String,<:Any})

Used by administrators to choose which groups in the directory should have access to upload
and download files over the enabled protocols using Transfer Family. For example, a
Microsoft Active Directory might contain 50,000 users, but only a small fraction might need
the ability to transfer files to the server. An administrator can use CreateAccess to limit
the access to the correct set of users who need this ability.

# Arguments
- `external_id`: A unique identifier that is required to identify specific groups within
  your directory. The users of the group that you associate have access to your Amazon S3 or
  Amazon EFS resources over the enabled protocols using Transfer Family. If you know the
  group name, you can view the SID values by running the following command using Windows
  PowerShell.  Get-ADGroup -Filter {samAccountName -like \"YourGroupName*\"} -Properties * |
  Select SamAccountName,ObjectSid  In that command, replace YourGroupName with the name of
  your Active Directory group. The regular expression used to validate this parameter is a
  string of characters consisting of uppercase and lowercase alphanumeric characters with no
  spaces. You can also include underscores or any of the following characters: =,.@:/-
- `role`: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role
  that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The
  policies attached to this role determine the level of access that you want to provide your
  users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file
  system. The IAM role should also contain a trust relationship that allows the server to
  access your resources when servicing your users' transfer requests.
- `server_id`: A system-assigned unique identifier for a server instance. This is the
  specific server that you added your user to.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"HomeDirectory"`: The landing directory (folder) for a user when they log in to the
  server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
- `"HomeDirectoryMappings"`: Logical directory mappings that specify what Amazon S3 or
  Amazon EFS paths and keys should be visible to your user and how you want to make them
  visible. You must specify the Entry and Target pair, where Entry shows how the path is made
  visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a
  target, it is displayed as is. You also must ensure that your Identity and Access
  Management (IAM) role provides access to paths in Target. This value can be set only when
  HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example.  [
  { \"Entry\": \"/directory1\", \"Target\": \"/bucket_name/home/mydirectory\" } ]  In most
  cases, you can use this value instead of the session policy to lock down your user to the
  designated home directory (\"chroot\"). To do this, you can set Entry to / and set Target
  to the HomeDirectory parameter value. The following is an Entry and Target pair example for
  chroot.  [ { \"Entry\": \"/\", \"Target\": \"/bucket_name/home/mydirectory\" } ]
- `"HomeDirectoryType"`: The type of landing directory (folder) that you want your users'
  home directory to be when they log in to the server. If you set it to PATH, the user will
  see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol
  clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings
  for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
- `"Policy"`: A session policy for your user so that you can use the same Identity and
  Access Management (IAM) role across multiple users. This policy scopes down a user's access
  to portions of their Amazon S3 bucket. Variables that you can use inside this policy
  include {Transfer:UserName}, {Transfer:HomeDirectory}, and {Transfer:HomeBucket}.  This
  policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use
  session policies. For session policies, Transfer Family stores the policy as a JSON blob,
  instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob
  and pass it in the Policy argument. For an example of a session policy, see Example session
  policy. For more information, see AssumeRole in the Security Token Service API Reference.
- `"PosixProfile"`:
"""
function create_access(
    ExternalId, Role, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "CreateAccess",
        Dict{String,Any}(
            "ExternalId" => ExternalId, "Role" => Role, "ServerId" => ServerId
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function create_access(
    ExternalId,
    Role,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "CreateAccess",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "ExternalId" => ExternalId, "Role" => Role, "ServerId" => ServerId
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    create_agreement(access_role, base_directory, local_profile_id, partner_profile_id, server_id)
    create_agreement(access_role, base_directory, local_profile_id, partner_profile_id, server_id, params::Dict{String,<:Any})

Creates an agreement. An agreement is a bilateral trading partner agreement, or
partnership, between an Transfer Family server and an AS2 process. The agreement defines
the file and message transfer relationship between the server and the AS2 process. To
define an agreement, Transfer Family combines a server, local profile, partner profile,
certificate, and other attributes. The partner is identified with the PartnerProfileId, and
the AS2 process is identified with the LocalProfileId.

# Arguments
- `access_role`: With AS2, you can send files by calling StartFileTransfer and specifying
  the file paths in the request parameter, SendFilePaths. We use the file’s parent
  directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is
  /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we
  receive them from the partner, and write a final JSON file containing relevant metadata of
  the transmission. So, the AccessRole needs to provide read and write access to the parent
  directory of the file location used in the StartFileTransfer request. Additionally, you
  need to provide read and write access to the parent directory of the files that you intend
  to send with StartFileTransfer.
- `base_directory`: The landing directory (folder) for files transferred by using the AS2
  protocol. A BaseDirectory example is /DOC-EXAMPLE-BUCKET/home/mydirectory .
- `local_profile_id`: A unique identifier for the AS2 local profile.
- `partner_profile_id`: A unique identifier for the partner profile used in the agreement.
- `server_id`: A system-assigned unique identifier for a server instance. This is the
  specific server that the agreement uses.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"Description"`: A name or short description to identify the agreement.
- `"Status"`: The status of the agreement. The agreement can be either ACTIVE or INACTIVE.
- `"Tags"`: Key-value pairs that can be used to group and search for agreements.
"""
function create_agreement(
    AccessRole,
    BaseDirectory,
    LocalProfileId,
    PartnerProfileId,
    ServerId;
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "CreateAgreement",
        Dict{String,Any}(
            "AccessRole" => AccessRole,
            "BaseDirectory" => BaseDirectory,
            "LocalProfileId" => LocalProfileId,
            "PartnerProfileId" => PartnerProfileId,
            "ServerId" => ServerId,
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function create_agreement(
    AccessRole,
    BaseDirectory,
    LocalProfileId,
    PartnerProfileId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "CreateAgreement",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "AccessRole" => AccessRole,
                    "BaseDirectory" => BaseDirectory,
                    "LocalProfileId" => LocalProfileId,
                    "PartnerProfileId" => PartnerProfileId,
                    "ServerId" => ServerId,
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    create_connector(access_role, as2_config, url)
    create_connector(access_role, as2_config, url, params::Dict{String,<:Any})

Creates the connector, which captures the parameters for an outbound connection for the AS2
protocol. The connector is required for sending files from a customer's non Amazon Web
Services server.

# Arguments
- `access_role`: With AS2, you can send files by calling StartFileTransfer and specifying
  the file paths in the request parameter, SendFilePaths. We use the file’s parent
  directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is
  /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we
  receive them from the partner, and write a final JSON file containing relevant metadata of
  the transmission. So, the AccessRole needs to provide read and write access to the parent
  directory of the file location used in the StartFileTransfer request. Additionally, you
  need to provide read and write access to the parent directory of the files that you intend
  to send with StartFileTransfer.
- `as2_config`: A structure that contains the parameters for a connector object.
- `url`: The URL of the partner's AS2 endpoint.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"LoggingRole"`: The Amazon Resource Name (ARN) of the Identity and Access Management
  (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When
  set, you can view connector activity in your CloudWatch logs.
- `"Tags"`: Key-value pairs that can be used to group and search for connectors. Tags are
  metadata attached to connectors for any purpose.
"""
function create_connector(
    AccessRole, As2Config, Url; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "CreateConnector",
        Dict{String,Any}(
            "AccessRole" => AccessRole, "As2Config" => As2Config, "Url" => Url
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function create_connector(
    AccessRole,
    As2Config,
    Url,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "CreateConnector",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "AccessRole" => AccessRole, "As2Config" => As2Config, "Url" => Url
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    create_profile(as2_id, profile_type)
    create_profile(as2_id, profile_type, params::Dict{String,<:Any})

Creates the profile for the AS2 process. The agreement is between the partner and the AS2
process.

# Arguments
- `as2_id`: The As2Id is the AS2-name, as defined in the RFC 4130. For inbound transfers,
  this is the AS2-From header for the AS2 messages sent from the partner. For outbound
  connectors, this is the AS2-To header for the AS2 messages sent to the partner using the
  StartFileTransfer API operation. This ID cannot include spaces.
- `profile_type`: Indicates whether to list only LOCAL type profiles or only PARTNER type
  profiles. If not supplied in the request, the command lists all types of profiles.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"CertificateIds"`: An array of identifiers for the imported certificates. You use this
  identifier for working with profiles and partner profiles.
- `"Tags"`: Key-value pairs that can be used to group and search for AS2 profiles.
"""
function create_profile(
    As2Id, ProfileType; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "CreateProfile",
        Dict{String,Any}("As2Id" => As2Id, "ProfileType" => ProfileType);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function create_profile(
    As2Id,
    ProfileType,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "CreateProfile",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("As2Id" => As2Id, "ProfileType" => ProfileType),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    create_server()
    create_server(params::Dict{String,<:Any})

Instantiates an auto-scaling virtual server based on the selected file transfer protocol in
Amazon Web Services. When you make updates to your file transfer protocol-enabled server or
when you work with users, use the service-generated ServerId property that is assigned to
the newly created server.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"Certificate"`: The Amazon Resource Name (ARN) of the Certificate Manager (ACM)
  certificate. Required when Protocols is set to FTPS. To request a new public certificate,
  see Request a public certificate in the Certificate Manager User Guide. To import an
  existing certificate into ACM, see Importing certificates into ACM in the Certificate
  Manager User Guide. To request a private certificate to use FTPS through private IP
  addresses, see Request a private certificate in the Certificate Manager User Guide.
  Certificates with the following cryptographic algorithms and key sizes are supported:
  2048-bit RSA (RSA_2048)   4096-bit RSA (RSA_4096)   Elliptic Prime Curve 256 bit
  (EC_prime256v1)   Elliptic Prime Curve 384 bit (EC_secp384r1)   Elliptic Prime Curve 521
  bit (EC_secp521r1)    The certificate must be a valid SSL/TLS X.509 version 3 certificate
  with FQDN or IP address specified and information about the issuer.
- `"Domain"`: The domain of the storage system that is used for file transfers. There are
  two domains available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File
  System (Amazon EFS). The default value is S3.  After the server is created, the domain
  cannot be changed.
- `"EndpointDetails"`: The virtual private cloud (VPC) endpoint settings that are
  configured for your server. When you host your endpoint within your VPC, you can make your
  endpoint accessible only to resources within your VPC, or you can attach Elastic IP
  addresses and make your endpoint accessible to clients over the internet. Your VPC's
  default security groups are automatically assigned to your endpoint.
- `"EndpointType"`: The type of endpoint that you want your server to use. You can choose
  to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC.
  With an endpoint that is hosted in a VPC, you can restrict access to your server and
  resources only within your VPC or choose to make it internet facing by attaching Elastic IP
  addresses directly to it.   After May 19, 2021, you won't be able to create a server using
  EndpointType=VPC_ENDPOINT in your Amazon Web Services account if your account hasn't
  already done so before May 19, 2021. If you have already created servers with
  EndpointType=VPC_ENDPOINT in your Amazon Web Services account on or before May 19, 2021,
  you will not be affected. After this date, use EndpointType=VPC. For more information, see
  https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vp
  c-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint
  type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP
  included) with your server's endpoint and use VPC security groups to restrict traffic by
  the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
- `"HostKey"`: The RSA, ECDSA, or ED25519 private key to use for your server. Use the
  following command to generate an RSA 2048 bit key with no passphrase:  ssh-keygen -t rsa -b
  2048 -N \"\" -m PEM -f my-new-server-key. Use a minimum value of 2048 for the -b option.
  You can create a stronger key by using 3072 or 4096. Use the following command to generate
  an ECDSA 256 bit key with no passphrase:  ssh-keygen -t ecdsa -b 256 -N \"\" -m PEM -f
  my-new-server-key. Valid values for the -b option for ECDSA are 256, 384, and 521. Use the
  following command to generate an ED25519 key with no passphrase:  ssh-keygen -t ed25519 -N
  \"\" -f my-new-server-key. For all of these commands, you can replace my-new-server-key
  with a string of your choice.  If you aren't planning to migrate existing users from an
  existing SFTP-enabled server to a new server, don't update the host key. Accidentally
  changing a server's host key can be disruptive.  For more information, see Change the host
  key for your SFTP-enabled server in the Transfer Family User Guide.
- `"IdentityProviderDetails"`: Required when IdentityProviderType is set to
  AWS_DIRECTORY_SERVICE or API_GATEWAY. Accepts an array containing all of the information
  required to use a directory in AWS_DIRECTORY_SERVICE or invoke a customer-supplied
  authentication API, including the API Gateway URL. Not required when IdentityProviderType
  is set to SERVICE_MANAGED.
- `"IdentityProviderType"`: The mode of authentication for a server. The default value is
  SERVICE_MANAGED, which allows you to store and access user credentials within the Transfer
  Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in
  Directory Service for Microsoft Active Directory or Microsoft Active Directory in your
  on-premises environment or in Amazon Web Services using AD Connector. This option also
  requires you to provide a Directory ID by using the IdentityProviderDetails parameter. Use
  the API_GATEWAY value to integrate with an identity provider of your choosing. The
  API_GATEWAY setting requires you to provide an Amazon API Gateway endpoint URL to call for
  authentication by using the IdentityProviderDetails parameter. Use the AWS_LAMBDA value to
  directly use an Lambda function as your identity provider. If you choose this value, you
  must specify the ARN for the Lambda function in the Function parameter or the
  IdentityProviderDetails data type.
- `"LoggingRole"`: The Amazon Resource Name (ARN) of the Identity and Access Management
  (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or
  Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
- `"PostAuthenticationLoginBanner"`: Specifies a string to display when users connect to a
  server. This string is displayed after the user authenticates.  The SFTP protocol does not
  support post-authentication display banners.
- `"PreAuthenticationLoginBanner"`: Specifies a string to display when users connect to a
  server. This string is displayed before the user authenticates. For example, the following
  banner displays details about using the system:  This system is for the use of authorized
  users only. Individuals using this computer system without authority, or in excess of their
  authority, are subject to having all of their activities on this system monitored and
  recorded by system personnel.
- `"ProtocolDetails"`: The protocol settings that are configured for your server.    To
  indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a
  single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or
  load balancer.    To ignore the error that is generated when the client attempts to use the
  SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the
  SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and
  upload files without needing to make any changes to your SFTP client, set the value to
  ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family
  generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client
  is making a SETSTAT call.   To determine whether your Transfer Family server resumes
  recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode
  parameter.    As2Transports indicates the transport method for the AS2 messages. Currently,
  only HTTP is supported.
- `"Protocols"`: Specifies the file transfer protocol or protocols over which your file
  transfer protocol client can connect to your server's endpoint. The available protocols
  are:    SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH    FTPS
  (File Transfer Protocol Secure): File transfer with TLS encryption    FTP (File Transfer
  Protocol): Unencrypted file transfer    AS2 (Applicability Statement 2): used for
  transporting structured business-to-business data      If you select FTPS, you must choose
  a certificate stored in Certificate Manager (ACM) which is used to identify your server
  when clients connect to it over FTPS.   If Protocol includes either FTP or FTPS, then the
  EndpointType must be VPC and the IdentityProviderType must be AWS_DIRECTORY_SERVICE or
  API_GATEWAY.   If Protocol includes FTP, then AddressAllocationIds cannot be associated.
  If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the
  IdentityProviderType can be set to SERVICE_MANAGED.   If Protocol includes AS2, then the
  EndpointType must be VPC, and domain must be Amazon S3.
- `"SecurityPolicyName"`: Specifies the name of the security policy that is attached to the
  server.
- `"Tags"`: Key-value pairs that can be used to group and search for servers.
- `"WorkflowDetails"`: Specifies the workflow ID for the workflow to assign and the
  execution role that's used for executing the workflow.
"""
function create_server(; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer("CreateServer"; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET)
end
function create_server(
    params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "CreateServer", params; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end

"""
    create_user(role, server_id, user_name)
    create_user(role, server_id, user_name, params::Dict{String,<:Any})

Creates a user and associates them with an existing file transfer protocol-enabled server.
You can only create and associate users with servers that have the IdentityProviderType set
to SERVICE_MANAGED. Using parameters for CreateUser, you can specify the user name, set the
home directory, store the user's public key, and assign the user's Identity and Access
Management (IAM) role. You can also optionally add a session policy, and assign metadata
with tags that can be used to group and search for users.

# Arguments
- `role`: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role
  that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The
  policies attached to this role determine the level of access that you want to provide your
  users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file
  system. The IAM role should also contain a trust relationship that allows the server to
  access your resources when servicing your users' transfer requests.
- `server_id`: A system-assigned unique identifier for a server instance. This is the
  specific server that you added your user to.
- `user_name`: A unique string that identifies a user and is associated with a ServerId.
  This user name must be a minimum of 3 and a maximum of 100 characters long. The following
  are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign
  '@'. The user name can't start with a hyphen, period, or at sign.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"HomeDirectory"`: The landing directory (folder) for a user when they log in to the
  server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
- `"HomeDirectoryMappings"`: Logical directory mappings that specify what Amazon S3 or
  Amazon EFS paths and keys should be visible to your user and how you want to make them
  visible. You must specify the Entry and Target pair, where Entry shows how the path is made
  visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a
  target, it is displayed as is. You also must ensure that your Identity and Access
  Management (IAM) role provides access to paths in Target. This value can be set only when
  HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example.  [
  { \"Entry\": \"/directory1\", \"Target\": \"/bucket_name/home/mydirectory\" } ]  In most
  cases, you can use this value instead of the session policy to lock your user down to the
  designated home directory (\"chroot\"). To do this, you can set Entry to / and set Target
  to the HomeDirectory parameter value. The following is an Entry and Target pair example for
  chroot.  [ { \"Entry\": \"/\", \"Target\": \"/bucket_name/home/mydirectory\" } ]
- `"HomeDirectoryType"`: The type of landing directory (folder) that you want your users'
  home directory to be when they log in to the server. If you set it to PATH, the user will
  see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol
  clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings
  for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
- `"Policy"`: A session policy for your user so that you can use the same Identity and
  Access Management (IAM) role across multiple users. This policy scopes down a user's access
  to portions of their Amazon S3 bucket. Variables that you can use inside this policy
  include {Transfer:UserName}, {Transfer:HomeDirectory}, and {Transfer:HomeBucket}.  This
  policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use
  session policies. For session policies, Transfer Family stores the policy as a JSON blob,
  instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob
  and pass it in the Policy argument. For an example of a session policy, see Example session
  policy. For more information, see AssumeRole in the Amazon Web Services Security Token
  Service API Reference.
- `"PosixProfile"`: Specifies the full POSIX identity, including user ID (Uid), group ID
  (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to
  your Amazon EFS file systems. The POSIX permissions that are set on files and directories
  in Amazon EFS determine the level of access your users get when transferring files into and
  out of your Amazon EFS file systems.
- `"SshPublicKeyBody"`: The public portion of the Secure Shell (SSH) key used to
  authenticate the user to the server. Transfer Family accepts RSA, ECDSA, and ED25519 keys.
- `"Tags"`: Key-value pairs that can be used to group and search for users. Tags are
  metadata attached to users for any purpose.
"""
function create_user(
    Role, ServerId, UserName; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "CreateUser",
        Dict{String,Any}("Role" => Role, "ServerId" => ServerId, "UserName" => UserName);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function create_user(
    Role,
    ServerId,
    UserName,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "CreateUser",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "Role" => Role, "ServerId" => ServerId, "UserName" => UserName
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    create_workflow(steps)
    create_workflow(steps, params::Dict{String,<:Any})

 Allows you to create a workflow with specified steps and step details the workflow invokes
after file transfer completes. After creating a workflow, you can associate the workflow
created with any transfer servers by specifying the workflow-details field in CreateServer
and UpdateServer operations.

# Arguments
- `steps`: Specifies the details for the steps that are in the specified workflow.  The
  TYPE specifies which of the following actions is being taken for this step.     COPY: Copy
  the file to another location.    CUSTOM: Perform a custom step with an Lambda function
  target.    DELETE: Delete the file.    TAG: Add a tag to the file.     Currently, copying
  and tagging are supported only on S3.    For file location, you specify either the S3
  bucket and key, or the EFS file system ID and path.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"Description"`: A textual description for the workflow.
- `"OnExceptionSteps"`: Specifies the steps (actions) to take if errors are encountered
  during execution of the workflow.  For custom steps, the lambda function needs to send
  FAILURE to the call back API to kick off the exception steps. Additionally, if the lambda
  does not send SUCCESS before it times out, the exception steps are executed.
- `"Tags"`: Key-value pairs that can be used to group and search for workflows. Tags are
  metadata attached to workflows for any purpose.
"""
function create_workflow(Steps; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "CreateWorkflow",
        Dict{String,Any}("Steps" => Steps);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function create_workflow(
    Steps, params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "CreateWorkflow",
        Dict{String,Any}(mergewith(_merge, Dict{String,Any}("Steps" => Steps), params));
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_access(external_id, server_id)
    delete_access(external_id, server_id, params::Dict{String,<:Any})

Allows you to delete the access specified in the ServerID and ExternalID parameters.

# Arguments
- `external_id`: A unique identifier that is required to identify specific groups within
  your directory. The users of the group that you associate have access to your Amazon S3 or
  Amazon EFS resources over the enabled protocols using Transfer Family. If you know the
  group name, you can view the SID values by running the following command using Windows
  PowerShell.  Get-ADGroup -Filter {samAccountName -like \"YourGroupName*\"} -Properties * |
  Select SamAccountName,ObjectSid  In that command, replace YourGroupName with the name of
  your Active Directory group. The regular expression used to validate this parameter is a
  string of characters consisting of uppercase and lowercase alphanumeric characters with no
  spaces. You can also include underscores or any of the following characters: =,.@:/-
- `server_id`: A system-assigned unique identifier for a server that has this user assigned.

"""
function delete_access(
    ExternalId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DeleteAccess",
        Dict{String,Any}("ExternalId" => ExternalId, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_access(
    ExternalId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteAccess",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("ExternalId" => ExternalId, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_agreement(agreement_id, server_id)
    delete_agreement(agreement_id, server_id, params::Dict{String,<:Any})

Delete the agreement that's specified in the provided AgreementId.

# Arguments
- `agreement_id`: A unique identifier for the agreement. This identifier is returned when
  you create an agreement.
- `server_id`: The server ID associated with the agreement that you are deleting.

"""
function delete_agreement(
    AgreementId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DeleteAgreement",
        Dict{String,Any}("AgreementId" => AgreementId, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_agreement(
    AgreementId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteAgreement",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("AgreementId" => AgreementId, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_certificate(certificate_id)
    delete_certificate(certificate_id, params::Dict{String,<:Any})

Deletes the certificate that's specified in the CertificateId parameter.

# Arguments
- `certificate_id`: The ID of the certificate object that you are deleting.

"""
function delete_certificate(
    CertificateId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DeleteCertificate",
        Dict{String,Any}("CertificateId" => CertificateId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_certificate(
    CertificateId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteCertificate",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("CertificateId" => CertificateId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_connector(connector_id)
    delete_connector(connector_id, params::Dict{String,<:Any})

Deletes the agreement that's specified in the provided ConnectorId.

# Arguments
- `connector_id`: The unique identifier for the connector.

"""
function delete_connector(ConnectorId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DeleteConnector",
        Dict{String,Any}("ConnectorId" => ConnectorId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_connector(
    ConnectorId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteConnector",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ConnectorId" => ConnectorId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_host_key(host_key_id, server_id)
    delete_host_key(host_key_id, server_id, params::Dict{String,<:Any})

Deletes the host key that's specified in the HoskKeyId parameter.

# Arguments
- `host_key_id`: The ID of the host key that you are deleting.
- `server_id`: Provide the ID of the server that contains the host key that you are
  deleting.

"""
function delete_host_key(
    HostKeyId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DeleteHostKey",
        Dict{String,Any}("HostKeyId" => HostKeyId, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_host_key(
    HostKeyId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteHostKey",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("HostKeyId" => HostKeyId, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_profile(profile_id)
    delete_profile(profile_id, params::Dict{String,<:Any})

Deletes the profile that's specified in the ProfileId parameter.

# Arguments
- `profile_id`: The ID of the profile that you are deleting.

"""
function delete_profile(ProfileId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DeleteProfile",
        Dict{String,Any}("ProfileId" => ProfileId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_profile(
    ProfileId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteProfile",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ProfileId" => ProfileId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_server(server_id)
    delete_server(server_id, params::Dict{String,<:Any})

Deletes the file transfer protocol-enabled server that you specify. No response returns
from this operation.

# Arguments
- `server_id`: A unique system-assigned identifier for a server instance.

"""
function delete_server(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DeleteServer",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_server(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteServer",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_ssh_public_key(server_id, ssh_public_key_id, user_name)
    delete_ssh_public_key(server_id, ssh_public_key_id, user_name, params::Dict{String,<:Any})

Deletes a user's Secure Shell (SSH) public key.

# Arguments
- `server_id`: A system-assigned unique identifier for a file transfer protocol-enabled
  server instance that has the user assigned to it.
- `ssh_public_key_id`: A unique identifier used to reference your user's specific SSH key.
- `user_name`: A unique string that identifies a user whose public key is being deleted.

"""
function delete_ssh_public_key(
    ServerId, SshPublicKeyId, UserName; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DeleteSshPublicKey",
        Dict{String,Any}(
            "ServerId" => ServerId,
            "SshPublicKeyId" => SshPublicKeyId,
            "UserName" => UserName,
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_ssh_public_key(
    ServerId,
    SshPublicKeyId,
    UserName,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteSshPublicKey",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "ServerId" => ServerId,
                    "SshPublicKeyId" => SshPublicKeyId,
                    "UserName" => UserName,
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_user(server_id, user_name)
    delete_user(server_id, user_name, params::Dict{String,<:Any})

Deletes the user belonging to a file transfer protocol-enabled server you specify. No
response returns from this operation.  When you delete a user from a server, the user's
information is lost.

# Arguments
- `server_id`: A system-assigned unique identifier for a server instance that has the user
  assigned to it.
- `user_name`: A unique string that identifies a user that is being deleted from a server.

"""
function delete_user(ServerId, UserName; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DeleteUser",
        Dict{String,Any}("ServerId" => ServerId, "UserName" => UserName);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_user(
    ServerId,
    UserName,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteUser",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("ServerId" => ServerId, "UserName" => UserName),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    delete_workflow(workflow_id)
    delete_workflow(workflow_id, params::Dict{String,<:Any})

Deletes the specified workflow.

# Arguments
- `workflow_id`: A unique identifier for the workflow.

"""
function delete_workflow(WorkflowId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DeleteWorkflow",
        Dict{String,Any}("WorkflowId" => WorkflowId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function delete_workflow(
    WorkflowId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DeleteWorkflow",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("WorkflowId" => WorkflowId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_access(external_id, server_id)
    describe_access(external_id, server_id, params::Dict{String,<:Any})

Describes the access that is assigned to the specific file transfer protocol-enabled
server, as identified by its ServerId property and its ExternalId. The response from this
call returns the properties of the access that is associated with the ServerId value that
was specified.

# Arguments
- `external_id`: A unique identifier that is required to identify specific groups within
  your directory. The users of the group that you associate have access to your Amazon S3 or
  Amazon EFS resources over the enabled protocols using Transfer Family. If you know the
  group name, you can view the SID values by running the following command using Windows
  PowerShell.  Get-ADGroup -Filter {samAccountName -like \"YourGroupName*\"} -Properties * |
  Select SamAccountName,ObjectSid  In that command, replace YourGroupName with the name of
  your Active Directory group. The regular expression used to validate this parameter is a
  string of characters consisting of uppercase and lowercase alphanumeric characters with no
  spaces. You can also include underscores or any of the following characters: =,.@:/-
- `server_id`: A system-assigned unique identifier for a server that has this access
  assigned.

"""
function describe_access(
    ExternalId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DescribeAccess",
        Dict{String,Any}("ExternalId" => ExternalId, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_access(
    ExternalId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeAccess",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("ExternalId" => ExternalId, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_agreement(agreement_id, server_id)
    describe_agreement(agreement_id, server_id, params::Dict{String,<:Any})

Describes the agreement that's identified by the AgreementId.

# Arguments
- `agreement_id`: A unique identifier for the agreement. This identifier is returned when
  you create an agreement.
- `server_id`: The server ID that's associated with the agreement.

"""
function describe_agreement(
    AgreementId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DescribeAgreement",
        Dict{String,Any}("AgreementId" => AgreementId, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_agreement(
    AgreementId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeAgreement",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("AgreementId" => AgreementId, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_certificate(certificate_id)
    describe_certificate(certificate_id, params::Dict{String,<:Any})

Describes the certificate that's identified by the CertificateId.

# Arguments
- `certificate_id`: An array of identifiers for the imported certificates. You use this
  identifier for working with profiles and partner profiles.

"""
function describe_certificate(
    CertificateId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DescribeCertificate",
        Dict{String,Any}("CertificateId" => CertificateId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_certificate(
    CertificateId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeCertificate",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("CertificateId" => CertificateId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_connector(connector_id)
    describe_connector(connector_id, params::Dict{String,<:Any})

Describes the connector that's identified by the ConnectorId.

# Arguments
- `connector_id`: The unique identifier for the connector.

"""
function describe_connector(ConnectorId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DescribeConnector",
        Dict{String,Any}("ConnectorId" => ConnectorId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_connector(
    ConnectorId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeConnector",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ConnectorId" => ConnectorId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_execution(execution_id, workflow_id)
    describe_execution(execution_id, workflow_id, params::Dict{String,<:Any})

You can use DescribeExecution to check the details of the execution of the specified
workflow.

# Arguments
- `execution_id`: A unique identifier for the execution of a workflow.
- `workflow_id`: A unique identifier for the workflow.

"""
function describe_execution(
    ExecutionId, WorkflowId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DescribeExecution",
        Dict{String,Any}("ExecutionId" => ExecutionId, "WorkflowId" => WorkflowId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_execution(
    ExecutionId,
    WorkflowId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeExecution",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("ExecutionId" => ExecutionId, "WorkflowId" => WorkflowId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_host_key(host_key_id, server_id)
    describe_host_key(host_key_id, server_id, params::Dict{String,<:Any})

Returns the details of the host key that's specified by the HostKeyId and ServerId.

# Arguments
- `host_key_id`: Provide the ID of the host key that you want described.
- `server_id`: Provide the ID of the server that contains the host key that you want
  described.

"""
function describe_host_key(
    HostKeyId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DescribeHostKey",
        Dict{String,Any}("HostKeyId" => HostKeyId, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_host_key(
    HostKeyId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeHostKey",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("HostKeyId" => HostKeyId, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_profile(profile_id)
    describe_profile(profile_id, params::Dict{String,<:Any})

Returns the details of the profile that's specified by the ProfileId.

# Arguments
- `profile_id`: The identifier of the profile that you want described.

"""
function describe_profile(ProfileId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DescribeProfile",
        Dict{String,Any}("ProfileId" => ProfileId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_profile(
    ProfileId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeProfile",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ProfileId" => ProfileId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_security_policy(security_policy_name)
    describe_security_policy(security_policy_name, params::Dict{String,<:Any})

Describes the security policy that is attached to your file transfer protocol-enabled
server. The response contains a description of the security policy's properties. For more
information about security policies, see Working with security policies.

# Arguments
- `security_policy_name`: Specifies the name of the security policy that is attached to the
  server.

"""
function describe_security_policy(
    SecurityPolicyName; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DescribeSecurityPolicy",
        Dict{String,Any}("SecurityPolicyName" => SecurityPolicyName);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_security_policy(
    SecurityPolicyName,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeSecurityPolicy",
        Dict{String,Any}(
            mergewith(
                _merge, Dict{String,Any}("SecurityPolicyName" => SecurityPolicyName), params
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_server(server_id)
    describe_server(server_id, params::Dict{String,<:Any})

Describes a file transfer protocol-enabled server that you specify by passing the ServerId
parameter. The response contains a description of a server's properties. When you set
EndpointType to VPC, the response will contain the EndpointDetails.

# Arguments
- `server_id`: A system-assigned unique identifier for a server.

"""
function describe_server(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DescribeServer",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_server(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeServer",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_user(server_id, user_name)
    describe_user(server_id, user_name, params::Dict{String,<:Any})

Describes the user assigned to the specific file transfer protocol-enabled server, as
identified by its ServerId property. The response from this call returns the properties of
the user associated with the ServerId value that was specified.

# Arguments
- `server_id`: A system-assigned unique identifier for a server that has this user assigned.
- `user_name`: The name of the user assigned to one or more servers. User names are part of
  the sign-in credentials to use the Transfer Family service and perform file transfer tasks.

"""
function describe_user(
    ServerId, UserName; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "DescribeUser",
        Dict{String,Any}("ServerId" => ServerId, "UserName" => UserName);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_user(
    ServerId,
    UserName,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeUser",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("ServerId" => ServerId, "UserName" => UserName),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    describe_workflow(workflow_id)
    describe_workflow(workflow_id, params::Dict{String,<:Any})

Describes the specified workflow.

# Arguments
- `workflow_id`: A unique identifier for the workflow.

"""
function describe_workflow(WorkflowId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "DescribeWorkflow",
        Dict{String,Any}("WorkflowId" => WorkflowId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function describe_workflow(
    WorkflowId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "DescribeWorkflow",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("WorkflowId" => WorkflowId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    import_certificate(certificate, usage)
    import_certificate(certificate, usage, params::Dict{String,<:Any})

Imports the signing and encryption certificates that you need to create local (AS2)
profiles and partner profiles.

# Arguments
- `certificate`: The file that contains the certificate to import.
- `usage`: Specifies whether this certificate is used for signing or encryption.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"ActiveDate"`: An optional date that specifies when the certificate becomes active.
- `"CertificateChain"`: An optional list of certificates that make up the chain for the
  certificate that's being imported.
- `"Description"`: A short description that helps identify the certificate.
- `"InactiveDate"`: An optional date that specifies when the certificate becomes inactive.
- `"PrivateKey"`: The file that contains the private key for the certificate that's being
  imported.
- `"Tags"`: Key-value pairs that can be used to group and search for certificates.
"""
function import_certificate(
    Certificate, Usage; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ImportCertificate",
        Dict{String,Any}("Certificate" => Certificate, "Usage" => Usage);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function import_certificate(
    Certificate,
    Usage,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "ImportCertificate",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("Certificate" => Certificate, "Usage" => Usage),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    import_host_key(host_key_body, server_id)
    import_host_key(host_key_body, server_id, params::Dict{String,<:Any})

Adds a host key to the server specified by the ServerId parameter.

# Arguments
- `host_key_body`: The public key portion of an SSH key pair. Transfer Family accepts RSA,
  ECDSA, and ED25519 keys.
- `server_id`: Provide the ID of the server that contains the host key that you are
  importing.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"Description"`: Enter a text description to identify this host key.
- `"Tags"`: Key-value pairs that can be used to group and search for host keys.
"""
function import_host_key(
    HostKeyBody, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ImportHostKey",
        Dict{String,Any}("HostKeyBody" => HostKeyBody, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function import_host_key(
    HostKeyBody,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "ImportHostKey",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("HostKeyBody" => HostKeyBody, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    import_ssh_public_key(server_id, ssh_public_key_body, user_name)
    import_ssh_public_key(server_id, ssh_public_key_body, user_name, params::Dict{String,<:Any})

Adds a Secure Shell (SSH) public key to a user account identified by a UserName value
assigned to the specific file transfer protocol-enabled server, identified by ServerId. The
response returns the UserName value, the ServerId value, and the name of the SshPublicKeyId.

# Arguments
- `server_id`: A system-assigned unique identifier for a server.
- `ssh_public_key_body`: The public key portion of an SSH key pair. Transfer Family accepts
  RSA, ECDSA, and ED25519 keys.
- `user_name`: The name of the user account that is assigned to one or more servers.

"""
function import_ssh_public_key(
    ServerId, SshPublicKeyBody, UserName; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ImportSshPublicKey",
        Dict{String,Any}(
            "ServerId" => ServerId,
            "SshPublicKeyBody" => SshPublicKeyBody,
            "UserName" => UserName,
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function import_ssh_public_key(
    ServerId,
    SshPublicKeyBody,
    UserName,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "ImportSshPublicKey",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "ServerId" => ServerId,
                    "SshPublicKeyBody" => SshPublicKeyBody,
                    "UserName" => UserName,
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    list_accesses(server_id)
    list_accesses(server_id, params::Dict{String,<:Any})

Lists the details for all the accesses you have on your server.

# Arguments
- `server_id`: A system-assigned unique identifier for a server that has users assigned to
  it.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: Specifies the maximum number of access SIDs to return.
- `"NextToken"`: When you can get additional results from the ListAccesses call, a
  NextToken parameter is returned in the output. You can then pass in a subsequent command to
  the NextToken parameter to continue listing additional accesses.
"""
function list_accesses(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListAccesses",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function list_accesses(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "ListAccesses",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    list_agreements(server_id)
    list_agreements(server_id, params::Dict{String,<:Any})

Returns a list of the agreements for the server that's identified by the ServerId that you
supply. If you want to limit the results to a certain number, supply a value for the
MaxResults parameter. If you ran the command previously and received a value for NextToken,
you can supply that value to continue listing agreements from where you left off.

# Arguments
- `server_id`: The identifier of the server for which you want a list of agreements.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: The maximum number of agreements to return.
- `"NextToken"`: When you can get additional results from the ListAgreements call, a
  NextToken parameter is returned in the output. You can then pass in a subsequent command to
  the NextToken parameter to continue listing additional agreements.
"""
function list_agreements(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListAgreements",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function list_agreements(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "ListAgreements",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    list_certificates()
    list_certificates(params::Dict{String,<:Any})

Returns a list of the current certificates that have been imported into Transfer Family. If
you want to limit the results to a certain number, supply a value for the MaxResults
parameter. If you ran the command previously and received a value for the NextToken
parameter, you can supply that value to continue listing certificates from where you left
off.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: The maximum number of certificates to return.
- `"NextToken"`: When you can get additional results from the ListCertificates call, a
  NextToken parameter is returned in the output. You can then pass in a subsequent command to
  the NextToken parameter to continue listing additional certificates.
"""
function list_certificates(; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListCertificates"; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end
function list_certificates(
    params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ListCertificates", params; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end

"""
    list_connectors()
    list_connectors(params::Dict{String,<:Any})

Lists the connectors for the specified Region.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: The maximum number of connectors to return.
- `"NextToken"`: When you can get additional results from the ListConnectors call, a
  NextToken parameter is returned in the output. You can then pass in a subsequent command to
  the NextToken parameter to continue listing additional connectors.
"""
function list_connectors(; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListConnectors"; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end
function list_connectors(
    params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ListConnectors", params; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end

"""
    list_executions(workflow_id)
    list_executions(workflow_id, params::Dict{String,<:Any})

Lists all executions for the specified workflow.

# Arguments
- `workflow_id`: A unique identifier for the workflow.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: Specifies the maximum number of executions to return.
- `"NextToken"`:  ListExecutions returns the NextToken parameter in the output. You can
  then pass the NextToken parameter in a subsequent command to continue listing additional
  executions.  This is useful for pagination, for instance. If you have 100 executions for a
  workflow, you might only want to list first 10. If so, call the API by specifying the
  max-results:   aws transfer list-executions --max-results 10   This returns details for the
  first 10 executions, as well as the pointer (NextToken) to the eleventh execution. You can
  now call the API again, supplying the NextToken value you received:   aws transfer
  list-executions --max-results 10 --next-token somePointerReturnedFromPreviousListResult
  This call returns the next 10 executions, the 11th through the 20th. You can then repeat
  the call until the details for all 100 executions have been returned.
"""
function list_executions(WorkflowId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListExecutions",
        Dict{String,Any}("WorkflowId" => WorkflowId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function list_executions(
    WorkflowId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "ListExecutions",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("WorkflowId" => WorkflowId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    list_host_keys(server_id)
    list_host_keys(server_id, params::Dict{String,<:Any})

Returns a list of host keys for the server specified by the ServerId paramter.

# Arguments
- `server_id`: Provide the ID of the server that contains the host keys that you want to
  view.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: The maximum number of host keys to return.
- `"NextToken"`: When there are additional results that were not returned, a NextToken
  parameter is returned. You can use that value for a subsequent call to ListHostKeys to
  continue listing results.
"""
function list_host_keys(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListHostKeys",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function list_host_keys(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "ListHostKeys",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    list_profiles()
    list_profiles(params::Dict{String,<:Any})

Returns a list of the profiles for your system. If you want to limit the results to a
certain number, supply a value for the MaxResults parameter. If you ran the command
previously and received a value for NextToken, you can supply that value to continue
listing profiles from where you left off.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: The maximum number of profiles to return.
- `"NextToken"`: When there are additional results that were not returned, a NextToken
  parameter is returned. You can use that value for a subsequent call to ListProfiles to
  continue listing results.
- `"ProfileType"`: Indicates whether to list only LOCAL type profiles or only PARTNER type
  profiles. If not supplied in the request, the command lists all types of profiles.
"""
function list_profiles(; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer("ListProfiles"; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET)
end
function list_profiles(
    params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ListProfiles", params; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end

"""
    list_security_policies()
    list_security_policies(params::Dict{String,<:Any})

Lists the security policies that are attached to your file transfer protocol-enabled
servers.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: Specifies the number of security policies to return as a response to the
  ListSecurityPolicies query.
- `"NextToken"`: When additional results are obtained from the ListSecurityPolicies
  command, a NextToken parameter is returned in the output. You can then pass the NextToken
  parameter in a subsequent command to continue listing additional security policies.
"""
function list_security_policies(; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListSecurityPolicies"; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end
function list_security_policies(
    params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ListSecurityPolicies",
        params;
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    list_servers()
    list_servers(params::Dict{String,<:Any})

Lists the file transfer protocol-enabled servers that are associated with your Amazon Web
Services account.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: Specifies the number of servers to return as a response to the
  ListServers query.
- `"NextToken"`: When additional results are obtained from the ListServers command, a
  NextToken parameter is returned in the output. You can then pass the NextToken parameter in
  a subsequent command to continue listing additional servers.
"""
function list_servers(; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer("ListServers"; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET)
end
function list_servers(
    params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ListServers", params; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end

"""
    list_tags_for_resource(arn)
    list_tags_for_resource(arn, params::Dict{String,<:Any})

Lists all of the tags associated with the Amazon Resource Name (ARN) that you specify. The
resource can be a user, server, or role.

# Arguments
- `arn`: Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN
  is an identifier for a specific Amazon Web Services resource, such as a server, user, or
  role.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: Specifies the number of tags to return as a response to the
  ListTagsForResource request.
- `"NextToken"`: When you request additional results from the ListTagsForResource
  operation, a NextToken parameter is returned in the input. You can then pass in a
  subsequent command to the NextToken parameter to continue listing additional tags.
"""
function list_tags_for_resource(Arn; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListTagsForResource",
        Dict{String,Any}("Arn" => Arn);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function list_tags_for_resource(
    Arn, params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ListTagsForResource",
        Dict{String,Any}(mergewith(_merge, Dict{String,Any}("Arn" => Arn), params));
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    list_users(server_id)
    list_users(server_id, params::Dict{String,<:Any})

Lists the users for a file transfer protocol-enabled server that you specify by passing the
ServerId parameter.

# Arguments
- `server_id`: A system-assigned unique identifier for a server that has users assigned to
  it.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: Specifies the number of users to return as a response to the ListUsers
  request.
- `"NextToken"`: When you can get additional results from the ListUsers call, a NextToken
  parameter is returned in the output. You can then pass in a subsequent command to the
  NextToken parameter to continue listing additional users.
"""
function list_users(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "ListUsers",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function list_users(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "ListUsers",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    list_workflows()
    list_workflows(params::Dict{String,<:Any})

Lists all of your workflows.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"MaxResults"`: Specifies the maximum number of workflows to return.
- `"NextToken"`:  ListWorkflows returns the NextToken parameter in the output. You can then
  pass the NextToken parameter in a subsequent command to continue listing additional
  workflows.
"""
function list_workflows(; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer("ListWorkflows"; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET)
end
function list_workflows(
    params::AbstractDict{String}; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "ListWorkflows", params; aws_config=aws_config, feature_set=SERVICE_FEATURE_SET
    )
end

"""
    send_workflow_step_state(execution_id, status, token, workflow_id)
    send_workflow_step_state(execution_id, status, token, workflow_id, params::Dict{String,<:Any})

Sends a callback for asynchronous custom steps.  The ExecutionId, WorkflowId, and Token are
passed to the target resource during execution of a custom step of a workflow. You must
include those with their callback as well as providing a status.

# Arguments
- `execution_id`: A unique identifier for the execution of a workflow.
- `status`: Indicates whether the specified step succeeded or failed.
- `token`: Used to distinguish between multiple callbacks for multiple Lambda steps within
  the same execution.
- `workflow_id`: A unique identifier for the workflow.

"""
function send_workflow_step_state(
    ExecutionId,
    Status,
    Token,
    WorkflowId;
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "SendWorkflowStepState",
        Dict{String,Any}(
            "ExecutionId" => ExecutionId,
            "Status" => Status,
            "Token" => Token,
            "WorkflowId" => WorkflowId,
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function send_workflow_step_state(
    ExecutionId,
    Status,
    Token,
    WorkflowId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "SendWorkflowStepState",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "ExecutionId" => ExecutionId,
                    "Status" => Status,
                    "Token" => Token,
                    "WorkflowId" => WorkflowId,
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    start_file_transfer(connector_id, send_file_paths)
    start_file_transfer(connector_id, send_file_paths, params::Dict{String,<:Any})

Begins an outbound file transfer. You specify the ConnectorId and the file paths for where
to send the files.

# Arguments
- `connector_id`: The unique identifier for the connector.
- `send_file_paths`: An array of strings. Each string represents the absolute path for one
  outbound file transfer. For example,  DOC-EXAMPLE-BUCKET/myfile.txt .

"""
function start_file_transfer(
    ConnectorId, SendFilePaths; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "StartFileTransfer",
        Dict{String,Any}("ConnectorId" => ConnectorId, "SendFilePaths" => SendFilePaths);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function start_file_transfer(
    ConnectorId,
    SendFilePaths,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "StartFileTransfer",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "ConnectorId" => ConnectorId, "SendFilePaths" => SendFilePaths
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    start_server(server_id)
    start_server(server_id, params::Dict{String,<:Any})

Changes the state of a file transfer protocol-enabled server from OFFLINE to ONLINE. It has
no impact on a server that is already ONLINE. An ONLINE server can accept and process file
transfer jobs. The state of STARTING indicates that the server is in an intermediate state,
either not fully able to respond, or not fully online. The values of START_FAILED can
indicate an error condition. No response is returned from this call.

# Arguments
- `server_id`: A system-assigned unique identifier for a server that you start.

"""
function start_server(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "StartServer",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function start_server(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "StartServer",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    stop_server(server_id)
    stop_server(server_id, params::Dict{String,<:Any})

Changes the state of a file transfer protocol-enabled server from ONLINE to OFFLINE. An
OFFLINE server cannot accept and process file transfer jobs. Information tied to your
server, such as server and user properties, are not affected by stopping your server.
Stopping the server does not reduce or impact your file transfer protocol endpoint billing;
you must delete the server to stop being billed.  The state of STOPPING indicates that the
server is in an intermediate state, either not fully able to respond, or not fully offline.
The values of STOP_FAILED can indicate an error condition. No response is returned from
this call.

# Arguments
- `server_id`: A system-assigned unique identifier for a server that you stopped.

"""
function stop_server(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "StopServer",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function stop_server(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "StopServer",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    tag_resource(arn, tags)
    tag_resource(arn, tags, params::Dict{String,<:Any})

Attaches a key-value pair to a resource, as identified by its Amazon Resource Name (ARN).
Resources are users, servers, roles, and other entities. There is no response returned from
this call.

# Arguments
- `arn`: An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as
  a server, user, or role.
- `tags`: Key-value pairs assigned to ARNs that you can use to group and search for
  resources by type. You can attach this metadata to user accounts for any purpose.

"""
function tag_resource(Arn, Tags; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "TagResource",
        Dict{String,Any}("Arn" => Arn, "Tags" => Tags);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function tag_resource(
    Arn,
    Tags,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "TagResource",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("Arn" => Arn, "Tags" => Tags), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    test_identity_provider(server_id, user_name)
    test_identity_provider(server_id, user_name, params::Dict{String,<:Any})

If the IdentityProviderType of a file transfer protocol-enabled server is
AWS_DIRECTORY_SERVICE or API_Gateway, tests whether your identity provider is set up
successfully. We highly recommend that you call this operation to test your authentication
method as soon as you create your server. By doing so, you can troubleshoot issues with the
identity provider integration to ensure that your users can successfully use the service.
The ServerId and UserName parameters are required. The ServerProtocol, SourceIp, and
UserPassword are all optional.    You cannot use TestIdentityProvider if the
IdentityProviderType of your server is SERVICE_MANAGED.      If you provide any incorrect
values for any parameters, the Response field is empty.     If you provide a server ID for
a server that uses service-managed users, you get an error:    An error occurred
(InvalidRequestException) when calling the TestIdentityProvider operation: s-server-ID not
configured for external auth      If you enter a Server ID for the --server-id parameter
that does not identify an actual Transfer server, you receive the following error:   An
error occurred (ResourceNotFoundException) when calling the TestIdentityProvider operation:
Unknown server

# Arguments
- `server_id`: A system-assigned identifier for a specific server. That server's user
  authentication method is tested with a user name and password.
- `user_name`: The name of the user account to be tested.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"ServerProtocol"`: The type of file transfer protocol to be tested. The available
  protocols are:   Secure Shell (SSH) File Transfer Protocol (SFTP)   File Transfer Protocol
  Secure (FTPS)   File Transfer Protocol (FTP)
- `"SourceIp"`: The source IP address of the user account to be tested.
- `"UserPassword"`: The password of the user account to be tested.
"""
function test_identity_provider(
    ServerId, UserName; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "TestIdentityProvider",
        Dict{String,Any}("ServerId" => ServerId, "UserName" => UserName);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function test_identity_provider(
    ServerId,
    UserName,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "TestIdentityProvider",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("ServerId" => ServerId, "UserName" => UserName),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    untag_resource(arn, tag_keys)
    untag_resource(arn, tag_keys, params::Dict{String,<:Any})

Detaches a key-value pair from a resource, as identified by its Amazon Resource Name (ARN).
Resources are users, servers, roles, and other entities. No response is returned from this
call.

# Arguments
- `arn`: The value of the resource that will have the tag removed. An Amazon Resource Name
  (ARN) is an identifier for a specific Amazon Web Services resource, such as a server, user,
  or role.
- `tag_keys`: TagKeys are key-value pairs assigned to ARNs that can be used to group and
  search for resources by type. This metadata can be attached to resources for any purpose.

"""
function untag_resource(Arn, TagKeys; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "UntagResource",
        Dict{String,Any}("Arn" => Arn, "TagKeys" => TagKeys);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function untag_resource(
    Arn,
    TagKeys,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UntagResource",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("Arn" => Arn, "TagKeys" => TagKeys), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    update_access(external_id, server_id)
    update_access(external_id, server_id, params::Dict{String,<:Any})

Allows you to update parameters for the access specified in the ServerID and ExternalID
parameters.

# Arguments
- `external_id`: A unique identifier that is required to identify specific groups within
  your directory. The users of the group that you associate have access to your Amazon S3 or
  Amazon EFS resources over the enabled protocols using Transfer Family. If you know the
  group name, you can view the SID values by running the following command using Windows
  PowerShell.  Get-ADGroup -Filter {samAccountName -like \"YourGroupName*\"} -Properties * |
  Select SamAccountName,ObjectSid  In that command, replace YourGroupName with the name of
  your Active Directory group. The regular expression used to validate this parameter is a
  string of characters consisting of uppercase and lowercase alphanumeric characters with no
  spaces. You can also include underscores or any of the following characters: =,.@:/-
- `server_id`: A system-assigned unique identifier for a server instance. This is the
  specific server that you added your user to.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"HomeDirectory"`: The landing directory (folder) for a user when they log in to the
  server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
- `"HomeDirectoryMappings"`: Logical directory mappings that specify what Amazon S3 or
  Amazon EFS paths and keys should be visible to your user and how you want to make them
  visible. You must specify the Entry and Target pair, where Entry shows how the path is made
  visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a
  target, it is displayed as is. You also must ensure that your Identity and Access
  Management (IAM) role provides access to paths in Target. This value can be set only when
  HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example.  [
  { \"Entry\": \"/directory1\", \"Target\": \"/bucket_name/home/mydirectory\" } ]  In most
  cases, you can use this value instead of the session policy to lock down your user to the
  designated home directory (\"chroot\"). To do this, you can set Entry to / and set Target
  to the HomeDirectory parameter value. The following is an Entry and Target pair example for
  chroot.  [ { \"Entry\": \"/\", \"Target\": \"/bucket_name/home/mydirectory\" } ]
- `"HomeDirectoryType"`: The type of landing directory (folder) that you want your users'
  home directory to be when they log in to the server. If you set it to PATH, the user will
  see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol
  clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings
  for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
- `"Policy"`: A session policy for your user so that you can use the same Identity and
  Access Management (IAM) role across multiple users. This policy scopes down a user's access
  to portions of their Amazon S3 bucket. Variables that you can use inside this policy
  include {Transfer:UserName}, {Transfer:HomeDirectory}, and {Transfer:HomeBucket}.  This
  policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use
  session policies. For session policies, Transfer Family stores the policy as a JSON blob,
  instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob
  and pass it in the Policy argument. For an example of a session policy, see Example session
  policy. For more information, see AssumeRole in the Amazon Web ServicesSecurity Token
  Service API Reference.
- `"PosixProfile"`:
- `"Role"`: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role
  that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The
  policies attached to this role determine the level of access that you want to provide your
  users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file
  system. The IAM role should also contain a trust relationship that allows the server to
  access your resources when servicing your users' transfer requests.
"""
function update_access(
    ExternalId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "UpdateAccess",
        Dict{String,Any}("ExternalId" => ExternalId, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function update_access(
    ExternalId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UpdateAccess",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("ExternalId" => ExternalId, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    update_agreement(agreement_id, server_id)
    update_agreement(agreement_id, server_id, params::Dict{String,<:Any})

Updates some of the parameters for an existing agreement. Provide the AgreementId and the
ServerId for the agreement that you want to update, along with the new values for the
parameters to update.

# Arguments
- `agreement_id`: A unique identifier for the agreement. This identifier is returned when
  you create an agreement.
- `server_id`: A system-assigned unique identifier for a server instance. This is the
  specific server that the agreement uses.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"AccessRole"`: With AS2, you can send files by calling StartFileTransfer and specifying
  the file paths in the request parameter, SendFilePaths. We use the file’s parent
  directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is
  /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we
  receive them from the partner, and write a final JSON file containing relevant metadata of
  the transmission. So, the AccessRole needs to provide read and write access to the parent
  directory of the file location used in the StartFileTransfer request. Additionally, you
  need to provide read and write access to the parent directory of the files that you intend
  to send with StartFileTransfer.
- `"BaseDirectory"`: To change the landing directory (folder) for files that are
  transferred, provide the bucket folder that you want to use; for example,
  /DOC-EXAMPLE-BUCKET/home/mydirectory .
- `"Description"`: To replace the existing description, provide a short description for the
  agreement.
- `"LocalProfileId"`: A unique identifier for the AS2 local profile. To change the local
  profile identifier, provide a new value here.
- `"PartnerProfileId"`: A unique identifier for the partner profile. To change the partner
  profile identifier, provide a new value here.
- `"Status"`: You can update the status for the agreement, either activating an inactive
  agreement or the reverse.
"""
function update_agreement(
    AgreementId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "UpdateAgreement",
        Dict{String,Any}("AgreementId" => AgreementId, "ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function update_agreement(
    AgreementId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UpdateAgreement",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("AgreementId" => AgreementId, "ServerId" => ServerId),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    update_certificate(certificate_id)
    update_certificate(certificate_id, params::Dict{String,<:Any})

Updates the active and inactive dates for a certificate.

# Arguments
- `certificate_id`: The identifier of the certificate object that you are updating.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"ActiveDate"`: An optional date that specifies when the certificate becomes active.
- `"Description"`: A short description to help identify the certificate.
- `"InactiveDate"`: An optional date that specifies when the certificate becomes inactive.
"""
function update_certificate(
    CertificateId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "UpdateCertificate",
        Dict{String,Any}("CertificateId" => CertificateId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function update_certificate(
    CertificateId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UpdateCertificate",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("CertificateId" => CertificateId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    update_connector(connector_id)
    update_connector(connector_id, params::Dict{String,<:Any})

Updates some of the parameters for an existing connector. Provide the ConnectorId for the
connector that you want to update, along with the new values for the parameters to update.

# Arguments
- `connector_id`: The unique identifier for the connector.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"AccessRole"`: With AS2, you can send files by calling StartFileTransfer and specifying
  the file paths in the request parameter, SendFilePaths. We use the file’s parent
  directory (for example, for --send-file-paths /bucket/dir/file.txt, parent directory is
  /bucket/dir/) to temporarily store a processed AS2 message file, store the MDN when we
  receive them from the partner, and write a final JSON file containing relevant metadata of
  the transmission. So, the AccessRole needs to provide read and write access to the parent
  directory of the file location used in the StartFileTransfer request. Additionally, you
  need to provide read and write access to the parent directory of the files that you intend
  to send with StartFileTransfer.
- `"As2Config"`: A structure that contains the parameters for a connector object.
- `"LoggingRole"`: The Amazon Resource Name (ARN) of the Identity and Access Management
  (IAM) role that allows a connector to turn on CloudWatch logging for Amazon S3 events. When
  set, you can view connector activity in your CloudWatch logs.
- `"Url"`: The URL of the partner's AS2 endpoint.
"""
function update_connector(ConnectorId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "UpdateConnector",
        Dict{String,Any}("ConnectorId" => ConnectorId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function update_connector(
    ConnectorId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UpdateConnector",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ConnectorId" => ConnectorId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    update_host_key(description, host_key_id, server_id)
    update_host_key(description, host_key_id, server_id, params::Dict{String,<:Any})

Updates the description for the host key specified by the specified by the ServerId and
HostKeyId parameters.

# Arguments
- `description`: Provide an updated description for the host key.
- `host_key_id`: Provide the ID of the host key that you are updating.
- `server_id`: Provide the ID of the server that contains the host key that you are
  updating.

"""
function update_host_key(
    Description, HostKeyId, ServerId; aws_config::AbstractAWSConfig=global_aws_config()
)
    return transfer(
        "UpdateHostKey",
        Dict{String,Any}(
            "Description" => Description, "HostKeyId" => HostKeyId, "ServerId" => ServerId
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function update_host_key(
    Description,
    HostKeyId,
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UpdateHostKey",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}(
                    "Description" => Description,
                    "HostKeyId" => HostKeyId,
                    "ServerId" => ServerId,
                ),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    update_profile(profile_id)
    update_profile(profile_id, params::Dict{String,<:Any})

Updates some of the parameters for an existing profile. Provide the ProfileId for the
profile that you want to update, along with the new values for the parameters to update.

# Arguments
- `profile_id`: The identifier of the profile object that you are updating.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"CertificateIds"`: An array of identifiers for the imported certificates. You use this
  identifier for working with profiles and partner profiles.
"""
function update_profile(ProfileId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "UpdateProfile",
        Dict{String,Any}("ProfileId" => ProfileId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function update_profile(
    ProfileId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UpdateProfile",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ProfileId" => ProfileId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    update_server(server_id)
    update_server(server_id, params::Dict{String,<:Any})

Updates the file transfer protocol-enabled server's properties after that server has been
created. The UpdateServer call returns the ServerId of the server you updated.

# Arguments
- `server_id`: A system-assigned unique identifier for a server instance that the user
  account is assigned to.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"Certificate"`: The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate
  Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public
  certificate, see Request a public certificate in the  Amazon Web ServicesCertificate
  Manager User Guide. To import an existing certificate into ACM, see Importing certificates
  into ACM in the  Amazon Web ServicesCertificate Manager User Guide. To request a private
  certificate to use FTPS through private IP addresses, see Request a private certificate in
  the  Amazon Web ServicesCertificate Manager User Guide. Certificates with the following
  cryptographic algorithms and key sizes are supported:   2048-bit RSA (RSA_2048)   4096-bit
  RSA (RSA_4096)   Elliptic Prime Curve 256 bit (EC_prime256v1)   Elliptic Prime Curve 384
  bit (EC_secp384r1)   Elliptic Prime Curve 521 bit (EC_secp521r1)    The certificate must be
  a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and
  information about the issuer.
- `"EndpointDetails"`: The virtual private cloud (VPC) endpoint settings that are
  configured for your server. When you host your endpoint within your VPC, you can make your
  endpoint accessible only to resources within your VPC, or you can attach Elastic IP
  addresses and make your endpoint accessible to clients over the internet. Your VPC's
  default security groups are automatically assigned to your endpoint.
- `"EndpointType"`: The type of endpoint that you want your server to use. You can choose
  to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC.
  With an endpoint that is hosted in a VPC, you can restrict access to your server and
  resources only within your VPC or choose to make it internet facing by attaching Elastic IP
  addresses directly to it.   After May 19, 2021, you won't be able to create a server using
  EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already
  done so before May 19, 2021. If you have already created servers with
  EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you
  will not be affected. After this date, use EndpointType=VPC. For more information, see
  https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vp
  c-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint
  type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP
  included) with your server's endpoint and use VPC security groups to restrict traffic by
  the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
- `"HostKey"`: The RSA, ECDSA, or ED25519 private key to use for your server. Use the
  following command to generate an RSA 2048 bit key with no passphrase:  ssh-keygen -t rsa -b
  2048 -N \"\" -m PEM -f my-new-server-key. Use a minimum value of 2048 for the -b option.
  You can create a stronger key by using 3072 or 4096. Use the following command to generate
  an ECDSA 256 bit key with no passphrase:  ssh-keygen -t ecdsa -b 256 -N \"\" -m PEM -f
  my-new-server-key. Valid values for the -b option for ECDSA are 256, 384, and 521. Use the
  following command to generate an ED25519 key with no passphrase:  ssh-keygen -t ed25519 -N
  \"\" -f my-new-server-key. For all of these commands, you can replace my-new-server-key
  with a string of your choice.  If you aren't planning to migrate existing users from an
  existing SFTP-enabled server to a new server, don't update the host key. Accidentally
  changing a server's host key can be disruptive.  For more information, see Change the host
  key for your SFTP-enabled server in the Transfer Family User Guide.
- `"IdentityProviderDetails"`: An array containing all of the information required to call
  a customer's authentication API method.
- `"LoggingRole"`: The Amazon Resource Name (ARN) of the Identity and Access Management
  (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or
  Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.
- `"PostAuthenticationLoginBanner"`: Specifies a string to display when users connect to a
  server. This string is displayed after the user authenticates.  The SFTP protocol does not
  support post-authentication display banners.
- `"PreAuthenticationLoginBanner"`: Specifies a string to display when users connect to a
  server. This string is displayed before the user authenticates. For example, the following
  banner displays details about using the system:  This system is for the use of authorized
  users only. Individuals using this computer system without authority, or in excess of their
  authority, are subject to having all of their activities on this system monitored and
  recorded by system personnel.
- `"ProtocolDetails"`: The protocol settings that are configured for your server.    To
  indicate passive mode (for FTP and FTPS protocols), use the PassiveIp parameter. Enter a
  single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or
  load balancer.    To ignore the error that is generated when the client attempts to use the
  SETSTAT command on a file that you are uploading to an Amazon S3 bucket, use the
  SetStatOption parameter. To have the Transfer Family server ignore the SETSTAT command and
  upload files without needing to make any changes to your SFTP client, set the value to
  ENABLE_NO_OP. If you set the SetStatOption parameter to ENABLE_NO_OP, Transfer Family
  generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client
  is making a SETSTAT call.   To determine whether your Transfer Family server resumes
  recent, negotiated sessions through a unique session ID, use the TlsSessionResumptionMode
  parameter.    As2Transports indicates the transport method for the AS2 messages. Currently,
  only HTTP is supported.
- `"Protocols"`: Specifies the file transfer protocol or protocols over which your file
  transfer protocol client can connect to your server's endpoint. The available protocols
  are:    SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH    FTPS
  (File Transfer Protocol Secure): File transfer with TLS encryption    FTP (File Transfer
  Protocol): Unencrypted file transfer    AS2 (Applicability Statement 2): used for
  transporting structured business-to-business data      If you select FTPS, you must choose
  a certificate stored in Certificate Manager (ACM) which is used to identify your server
  when clients connect to it over FTPS.   If Protocol includes either FTP or FTPS, then the
  EndpointType must be VPC and the IdentityProviderType must be AWS_DIRECTORY_SERVICE or
  API_GATEWAY.   If Protocol includes FTP, then AddressAllocationIds cannot be associated.
  If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the
  IdentityProviderType can be set to SERVICE_MANAGED.   If Protocol includes AS2, then the
  EndpointType must be VPC, and domain must be Amazon S3.
- `"SecurityPolicyName"`: Specifies the name of the security policy that is attached to the
  server.
- `"WorkflowDetails"`: Specifies the workflow ID for the workflow to assign and the
  execution role that's used for executing the workflow. To remove an associated workflow
  from a server, you can provide an empty OnUpload object, as in the following example.  aws
  transfer update-server --server-id s-01234567890abcdef --workflow-details
  '{\"OnUpload\":[]}'
"""
function update_server(ServerId; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "UpdateServer",
        Dict{String,Any}("ServerId" => ServerId);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function update_server(
    ServerId,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UpdateServer",
        Dict{String,Any}(
            mergewith(_merge, Dict{String,Any}("ServerId" => ServerId), params)
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end

"""
    update_user(server_id, user_name)
    update_user(server_id, user_name, params::Dict{String,<:Any})

Assigns new properties to a user. Parameters you pass modify any or all of the following:
the home directory, role, and policy for the UserName and ServerId you specify. The
response returns the ServerId and the UserName for the updated user.

# Arguments
- `server_id`: A system-assigned unique identifier for a server instance that the user
  account is assigned to.
- `user_name`: A unique string that identifies a user and is associated with a server as
  specified by the ServerId. This user name must be a minimum of 3 and a maximum of 100
  characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
  '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at
  sign.

# Optional Parameters
Optional parameters can be passed as a `params::Dict{String,<:Any}`. Valid keys are:
- `"HomeDirectory"`: The landing directory (folder) for a user when they log in to the
  server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
- `"HomeDirectoryMappings"`: Logical directory mappings that specify what Amazon S3 or
  Amazon EFS paths and keys should be visible to your user and how you want to make them
  visible. You must specify the Entry and Target pair, where Entry shows how the path is made
  visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a
  target, it is displayed as is. You also must ensure that your Identity and Access
  Management (IAM) role provides access to paths in Target. This value can be set only when
  HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example.  [
  { \"Entry\": \"/directory1\", \"Target\": \"/bucket_name/home/mydirectory\" } ]  In most
  cases, you can use this value instead of the session policy to lock down your user to the
  designated home directory (\"chroot\"). To do this, you can set Entry to '/' and set Target
  to the HomeDirectory parameter value. The following is an Entry and Target pair example for
  chroot.  [ { \"Entry\": \"/\", \"Target\": \"/bucket_name/home/mydirectory\" } ]
- `"HomeDirectoryType"`: The type of landing directory (folder) that you want your users'
  home directory to be when they log in to the server. If you set it to PATH, the user will
  see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol
  clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings
  for how you want to make Amazon S3 or Amazon EFS paths visible to your users.
- `"Policy"`: A session policy for your user so that you can use the same Identity and
  Access Management (IAM) role across multiple users. This policy scopes down a user's access
  to portions of their Amazon S3 bucket. Variables that you can use inside this policy
  include {Transfer:UserName}, {Transfer:HomeDirectory}, and {Transfer:HomeBucket}.  This
  policy applies only when the domain of ServerId is Amazon S3. Amazon EFS does not use
  session policies. For session policies, Transfer Family stores the policy as a JSON blob,
  instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob
  and pass it in the Policy argument. For an example of a session policy, see Creating a
  session policy. For more information, see AssumeRole in the Amazon Web Services Security
  Token Service API Reference.
- `"PosixProfile"`: Specifies the full POSIX identity, including user ID (Uid), group ID
  (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to
  your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions that are set on files
  and directories in your file system determines the level of access your users get when
  transferring files into and out of your Amazon EFS file systems.
- `"Role"`: The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role
  that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The
  policies attached to this role determine the level of access that you want to provide your
  users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file
  system. The IAM role should also contain a trust relationship that allows the server to
  access your resources when servicing your users' transfer requests.
"""
function update_user(ServerId, UserName; aws_config::AbstractAWSConfig=global_aws_config())
    return transfer(
        "UpdateUser",
        Dict{String,Any}("ServerId" => ServerId, "UserName" => UserName);
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
function update_user(
    ServerId,
    UserName,
    params::AbstractDict{String};
    aws_config::AbstractAWSConfig=global_aws_config(),
)
    return transfer(
        "UpdateUser",
        Dict{String,Any}(
            mergewith(
                _merge,
                Dict{String,Any}("ServerId" => ServerId, "UserName" => UserName),
                params,
            ),
        );
        aws_config=aws_config,
        feature_set=SERVICE_FEATURE_SET,
    )
end
